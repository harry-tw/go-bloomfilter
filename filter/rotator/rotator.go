// Package rotator is used to rotate filter by period.
package rotator

import (
	"context"
	"github.com/x0rworld/go-bloomfilter/config"
	"github.com/x0rworld/go-bloomfilter/core"
	"github.com/x0rworld/go-bloomfilter/filter"
	"sync"
	"time"
)

// NewFilterFunc returns filter that will be performed by Rotator in handleRotating.
// It's the same signature with factory.FilterFactory.NewFilter.
type NewFilterFunc func(ctx context.Context) (filter.Filter, error)

type Rotator struct {
	ctx           context.Context
	cfg           config.RotatorConfig
	mutex         *sync.RWMutex
	newFilter     NewFilterFunc
	current, next filter.Filter
}

func (r *Rotator) handleRotating(freq time.Duration) {
	for {
		current := time.Now()
		next := current.Add(freq).Truncate(freq)
		timer := time.NewTimer(next.Sub(current))
		select {
		case <-timer.C:
			r.rotate()
		case <-r.ctx.Done():
			return
		}
	}
}

func (r *Rotator) rotate() error {
	next, err := r.genFilter(true)
	if err != nil {
		return err
	}

	r.mutex.Lock()
	defer r.mutex.Unlock()

	r.current = r.next
	r.next = next
	return err
}

func (r *Rotator) Exist(data string) (bool, error) {
	r.mutex.RLock()
	defer r.mutex.RUnlock()
	return r.current.Exist(data)
}

func (r *Rotator) Add(data string) error {
	r.mutex.RLock()
	defer r.mutex.RUnlock()
	err := r.current.Add(data)
	if err != nil {
		return err
	}
	return r.next.Add(data)
}

type filterPair struct {
	current, next filter.Filter
}

func (r *Rotator) genFilter(isNext bool) (filter.Filter, error) {
	// currently, only RedisBitmapFactory.NewBitmap() refers the value.
	val := core.BitmapFactoryCtxValue{
		IsRotatorEnabled: r.cfg.Enable,
		IsNextFilter:     isNext,
		RotatorMode:      r.cfg.Mode,
		Now:              time.Now(),
	}
	vCtx := context.WithValue(r.ctx, core.BitmapFactoryCtxKey, val)
	f, err := r.newFilter(vCtx)
	if err != nil {
		return nil, err
	}
	return f, nil
}

func (r *Rotator) genFilterPair() (*filterPair, error) {
	current, err := r.genFilter(false)
	if err != nil {
		return nil, err
	}
	next, err := r.genFilter(true)
	if err != nil {
		return nil, err
	}
	return &filterPair{
		current: current,
		next:    next,
	}, nil
}

// NewRotator returns *Rotator that rotates filter by period, all rotating filters will be generated by newFilter.
func NewRotator(ctx context.Context, cfg config.RotatorConfig, newFilter NewFilterFunc) (*Rotator, error) {
	r := &Rotator{
		ctx:       ctx,
		cfg:       cfg,
		mutex:     &sync.RWMutex{},
		newFilter: newFilter,
	}

	pair, err := r.genFilterPair()
	if err != nil {
		return nil, err
	}
	r.current = pair.current
	r.next = pair.next

	go r.handleRotating(cfg.Freq)

	return r, nil
}
