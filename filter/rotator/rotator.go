// Package rotator is used to rotate filter by period.
package rotator

import (
	"context"
	"github.com/x0rworld/go-bloomfilter/config"
	"github.com/x0rworld/go-bloomfilter/filter"
	"sync"
	"time"
)

// NewFilterFunc returns filter that will be performed by Rotator in handleRotating.
// It's the same signature with factory.FilterFactory.NewFilter.
type NewFilterFunc func(ctx context.Context) (filter.Filter, error)

type Rotator struct {
	ctx           context.Context
	cfg           config.RotatorConfig
	mutex         *sync.RWMutex
	newFilter     NewFilterFunc
	Current, Next filter.Filter
}

func (r *Rotator) handleRotating(ticker *time.Ticker) {
	for {
		select {
		case <-ticker.C:
			r.rotate()
		case <-r.ctx.Done():
			return
		}
	}
}

func (r *Rotator) rotate() error {
	r.mutex.Lock()
	defer r.mutex.Unlock()

	var err error
	r.Current = r.Next
	r.Next, err = r.newFilter(r.ctx)
	return err
}

func (r *Rotator) Exist(data string) (bool, error) {
	r.mutex.RLock()
	defer r.mutex.RUnlock()
	return r.Current.Exist(data)
}

func (r *Rotator) Add(data string) error {
	r.mutex.RLock()
	defer r.mutex.RUnlock()
	err := r.Current.Add(data)
	if err != nil {
		return err
	}
	return r.Next.Add(data)
}

// NewRotator returns *Rotator that rotates filter by period, all rotating filters will be generated by newFilter.
func NewRotator(ctx context.Context, cfg config.RotatorConfig, newFilter NewFilterFunc) (*Rotator, error) {
	current, err := newFilter(ctx)
	if err != nil {
		return nil, err
	}
	next, err := newFilter(ctx)
	if err != nil {
		return nil, err
	}

	r := &Rotator{
		ctx:       ctx,
		cfg:       cfg,
		mutex:     &sync.RWMutex{},
		newFilter: newFilter,
		Current:   current,
		Next:      next,
	}

	go r.handleRotating(time.NewTicker(cfg.Freq))

	return r, nil
}
