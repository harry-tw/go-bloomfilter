// Package rotator is used to rotate filter by period.
package rotator

import (
	"context"
	"github.com/x0rworld/go-bloomfilter/config"
	"github.com/x0rworld/go-bloomfilter/core"
	"github.com/x0rworld/go-bloomfilter/filter"
	"sync"
	"time"
)

// NewFilterFunc returns filter that will be performed by Rotator in handleRotating.
// It's the same signature with factory.FilterFactory.NewFilter.
type NewFilterFunc func(ctx context.Context) (filter.Filter, error)

type Rotator struct {
	ctx           context.Context
	cfg           config.RotatorConfig
	mutex         *sync.RWMutex
	newFilter     NewFilterFunc
	current, next filter.Filter
}

func (r *Rotator) handleRotating(freq time.Duration) {
	for {
		current := time.Now()
		next := current.Add(freq).Truncate(freq)
		timer := time.NewTimer(next.Sub(current))
		select {
		case <-timer.C:
			r.rotate()
		case <-r.ctx.Done():
			return
		}
	}
}

func (r *Rotator) rotate() error {
	next, err := genNextFilter(r.ctx, r.newFilter)
	if err != nil {
		return err
	}

	r.mutex.Lock()
	defer r.mutex.Unlock()

	r.current = r.next
	r.next = next
	return err
}

func (r *Rotator) Exist(data string) (bool, error) {
	r.mutex.RLock()
	defer r.mutex.RUnlock()
	return r.current.Exist(data)
}

func (r *Rotator) Add(data string) error {
	r.mutex.RLock()
	defer r.mutex.RUnlock()
	err := r.current.Add(data)
	if err != nil {
		return err
	}
	return r.next.Add(data)
}

type filterPair struct {
	current, next filter.Filter
}

func genNextFilter(ctx context.Context, newFilter NewFilterFunc) (filter.Filter, error) {
	// pass the context value to newFilter.
	// currently, only RedisBitmapFactory.NewBitmap in BloomFilterFactory.NewFilter refers to the context value for generating bitmap.
	nextCtx := context.WithValue(ctx, core.ContextKeyFactoryIsNextBm, true)
	next, err := newFilter(nextCtx)
	if err != nil {
		return nil, err
	}
	return next, nil
}

func genFilterPair(ctx context.Context, newFilter NewFilterFunc) (*filterPair, error) {
	current, err := newFilter(ctx)
	if err != nil {
		return nil, err
	}
	next, err := genNextFilter(ctx, newFilter)
	if err != nil {
		return nil, err
	}
	return &filterPair{
		current: current,
		next:    next,
	}, nil
}

// NewRotator returns *Rotator that rotates filter by period, all rotating filters will be generated by newFilter.
func NewRotator(ctx context.Context, cfg config.RotatorConfig, newFilter NewFilterFunc) (*Rotator, error) {
	pair, err := genFilterPair(ctx, newFilter)
	if err != nil {
		return nil, err
	}

	r := &Rotator{
		ctx:       ctx,
		cfg:       cfg,
		mutex:     &sync.RWMutex{},
		newFilter: newFilter,
		current:   pair.current,
		next:      pair.next,
	}

	go r.handleRotating(cfg.Freq)

	return r, nil
}
